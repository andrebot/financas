import jwt from 'jsonwebtoken';
import {
  Request, Response, NextFunction,
} from 'express';
import { Document, ObjectId, Types } from 'mongoose';
import type { IRepository } from './resources/repositories/IRepository';
/* eslint-disable no-unused-vars */

export type Content = { user: string };

/**
 * Interface for the Token
 */
export type Tokens = {
  /**
   * Access Token generated by the server
   */
  accessToken: string;
  /**
   * Refresh Token generated by the server
   */
  refreshToken: string;
};

/**
 * Interface for the Login Response
 */
export type LoginResponse = {
  /**
   * Access Token generated by the server
   */
  accessToken: string;
  /**
   * Refresh Token generated by the server
   */
  refreshToken: string;
  /**
   * User object
   */
  user: Omit<IUser, 'password'>;
};

/**
 * Interface for the Token
 */
export interface Token extends jwt.Jwt {
  /**
   * Payload of the token. It contains the email, role, first name and last name
   */
  payload: {
    /** Email of the user */
    email: string;
    /** Role of the user. Can be either 'admin' or 'user' */
    role: 'admin' | 'user';
    /** First name of the user */
    firstName: string;
    /** Last name of the user */
    lastName: string;
  }
}

/**
 * Interface for the User Payload
 */
export type UserPayload = {
  /** Email of the user */
  email?: string;
  /** First name of the user */
  firstName?: string;
  /** Last name of the user */
  lastName?: string;
  /** Role of the user. Can be either 'admin' or 'user' */
  role?: 'admin' | 'user';
  /** Id of the user */
  id?: string;
};

export interface RequestWithUser extends Request {
  user?: UserPayload;
}

/**
 * Interface for token validation middleware
 */
export type TokenValidationMiddleware = (
  req: RequestWithUser,
  res: Response,
  next: NextFunction,
) => void;

export interface IContentController {
  /**
   * Create content.
   *
   * @param req - The request object
   * @param res - The response object
   * @returns The created content
   */
  createContent(req: RequestWithUser, res: Response): Promise<Response>;
  /**
   * Update content. If the user is an admin, they can update any content.
   *
   * @param req - The request object
   * @param res - The response object
   * @returns The updated content
   */
  updateContent(req: RequestWithUser, res: Response): Promise<Response>;
  /**
   * Delete content by id. If the user is an admin, they can delete any content.
   * If the user is not an admin, they can only delete their own content.
   *
   * @param req - The request object
   * @param res - The response object
   * @returns The deleted content
   */
  deleteContent(req: RequestWithUser, res: Response): Promise<Response>;
  /**
   * List user content. If the user is an admin, they can list all content.
   *
   * @param req - The request object
   * @param res - The response object
   * @returns The list of content
   */
  listContent(req: RequestWithUser, res: Response): Promise<Response>;
  /**
   * Get content by id. If the user is an admin, they can get any content.
   *
   * @param req - The request object
   * @param res - The response object
   * @returns The content
   */
  getContent(req: RequestWithUser, res: Response): Promise<Response>;
}

export interface IBudgetController extends IContentController {
  /**
   * Get budget by id. If the user is an admin, they can get any budget.
   *
   * @param req - The request object
   * @param res - The response object
   * @returns The budget
   */
  getBudget(req: RequestWithUser, res: Response): Promise<Response>;
}

/**
 * Interface for the Card
 */
export interface ICard {
  /**
   * Id of the card
   */
  id?: string;
  /**
   * Number of the card
   */
  number: string;
  /**
   * Expiration date of the card
   */
  expirationDate: string;
}

/**
 * Mongoose document type for the Card
 */
export interface ICardDocument extends Omit<ICard, 'id'>, Document {}

/**
 * Interface for the Account
 */
export interface IAccount {
  /**
   * Id of the account
   */
  id?: string;
  /**
   * Name of the account
   */
  name: string;
  /**
   * Agency of the account
   */
  agency: string;
  /**
   * Account number
   */
  accountNumber: string;
  /**
   * Currency of the account
   */
  currency: string;
  /**
   * User of the account
   */
  user: string;
  /**
   * Cards of the account
   */
  cards: ICard[];
}

/**
 * Mongoose document type for the Account
 */
export interface IAccountDocument extends Omit<IAccount, 'id' | 'user'>, Document {
  _id: Types.ObjectId;
  user: ObjectId;
}

/**
 * Interface for the User
 */
export interface IUser {
  /**
   * Unique identifier of the user
   */
  id?: string; // Optional to account for new objects
  /**
   * Email of the user
   */
  email: string;
  /**
   * First name of the user
   */
  firstName: string;
  /**
   * Last name of the user
   */
  lastName: string;
  /**
   * Role of the user. Can be either 'admin' or 'user'
   */
  role: 'admin' | 'user';
  /**
   * Password of the user
   */
  password: string;
}

/**
 * Mongoose document type for the User
 */
export interface IUserDocument extends Omit<IUser, 'id'>, Document {
  _id: Types.ObjectId;
}

export enum TRANSACTION_TYPES {
  WITHDRAW = 'withdraw',
  DEPOSIT = 'deposit',
  TRANSFER = 'transfer',
  BANK_SLIP = 'bank_slip',
  CARD = 'card',
  INVESTMENT = 'investment',
}

export enum INVESTMENT_TYPES {
  CDB = 'cdb',
  LCI = 'lci',
  LCA = 'lca',
  STOCK = 'stock',
  FUND = 'fund',
  CRA = 'cra',
  CRI = 'cri',
  DEBENTURE = 'debenture',
  CURRENCY = 'currency',
  LC = 'lc',
  LF = 'lf',
  FII = 'fii',
  TRESURY = 'tresury',
}

export interface IGoalItem {
  goal: IGoal;
  goalName: string;
  percentage: number;
}

export interface ITransaction {
  id?: string;
  name: string;
  category: string;
  parentCategory: string;
  account: string;
  type: TRANSACTION_TYPES;
  date: Date | string;
  value: number;
  investmentType?: INVESTMENT_TYPES;
  user: string;
  goalsList: IGoalItem[];
}

/**
 * Mongoose document type for the Transaction
 */
export interface ITransactionDocument extends Omit<ITransaction, 'id' | 'user' | 'goalsList' | 'account'>, Document {
  _id: Types.ObjectId;
  user: ObjectId;
  account: ObjectId;
  goalsList: {
    goal: Types.ObjectId;
    goalName: string;
    percentage: number;
  }[];
}

export interface IGoal extends Content {
  /**
   * Unique identifier
   */
  id?: string;
  /**
   * Name of the Goal
   */
  name: string;
  /**
   * Goal's target value
   */
  value: number;
  /**
   * Due date for the goal
   */
  dueDate: Date;
  /**
   * Goal owner
   */
  user: string;
  /**
   * Saved value of the goal
   */
  savedValue: number;
}

/**
 * Mongoose document type for the Goal
 */
export interface IGoalDocument extends Omit<IGoal, 'id' | 'user'>, Document {
  _id: Types.ObjectId;
  user: ObjectId;
}

export interface ICategory {
  /**
   * Unique identifier
   */
  id?: string;
  /**
   * Name of the category
   */
  name: string;
  /**
   * Category owner
   */
  user: string;
  /**
   * Parent category, if this is a sub-category
   */
  parentCategory?: string;
}

/**
 * Mongoose document type for the Category
 */
export interface ICategoryDocument extends Omit<ICategory, 'id' | 'user' | 'parentCategory'>, Document {
  _id: Types.ObjectId;
  user: ObjectId;
  parentCategory: ObjectId;
}

export enum BUDGET_TYPES {
  ANNUALY = 'annualy',
  QUARTERLY = 'quarterly',
  MONTHLY = 'monthly',
  WEEKLY = 'weekly',
  DAILY = 'daily',
}

export interface IBudget extends Content {
  /**
   * Unique identifier of the budget
   */
  id?: string;
  /**
   * Budget's name
   */
  name: string;
  /**
   * Budget's target value
   */
  value: number;
  /**
   * Budget type
   */
  type: BUDGET_TYPES;
  /**
   * Budget's spent value
   */
  spent?: number;
  /**
   * Budget's start date
   */
  startDate: Date;
  /**
   * Budget's end date
   */
  endDate: Date;
  /**
   * Categories related to this budget
   */
  categories: string[];
  /**
   * Budget owner
   */
  user: string;
}

/**
 * Mongoose document type for the Budget
 */
export interface IBudgetDocument extends Omit<IBudget, 'id' | 'user'>, Document {
  _id: Types.ObjectId;
  user: ObjectId;
}

export interface IMonthlyBalance {
  /**
   * Unique identifier
   */
  id?: string;
  /**
   * Monthly balance owner
   */
  user: string;
  /**
   * Monthly balance account
   */
  account: string;
  /**
   * Month of the monthly balance
   */
  month: number;
  /**
   * Year of the monthly balance
   */
  year: number;
  /**
   * Opening balance of the monthly balance
   */
  openingBalance: number;
  /**
   * Closing balance of the monthly balance
   */
  closingBalance: number;
  /**
   * Transactions of the monthly balance
   */
  transactions: ITransaction[];
}

/**
 * Mongoose document type for the Monthly Balance
 */
export interface IMonthlyBalanceDocument extends Omit<IMonthlyBalance, 'id' | 'user' | 'account' | 'transactions'>, Document {
  user: ObjectId;
  account: ObjectId;
  transactions: ObjectId[];
}

export type BulkGoalsUpdate = {
  goalId: string;
  amount: number;
};

/**
 * Repository interfaces - extend IRepository with repo-specific methods.
 * Use these instead of typeof for dependency injection and testability.
 */
export interface ITransactionRepo extends IRepository<ITransactionDocument, ITransaction> {
  deleteGoalFromTransactions(goalId: string): Promise<number>;
  removeCategoriesFromTransactions(categoryIds: string[]): Promise<number>;
  findByCategoryWithDateRange(
    userId: string,
    categories: string[],
    startDate: Date,
    endDate: Date,
  ): Promise<ITransaction[] | { value: number }[]>;
}

export interface ICategoryRepo extends IRepository<ICategoryDocument, ICategory> {
  findAllSubcategories(parentCategoryId: string): Promise<ICategory[]>;
  deleteAllSubcategories(parentCategoryId: string): Promise<number>;
}

export interface IBudgetRepo extends IRepository<IBudgetDocument, IBudget> {
  updateBudgetsByNewTransaction(transaction: ITransaction): Promise<void>;
}

export interface IGoalRepo extends IRepository<IGoalDocument, IGoal> {
  incrementGoalsInBulk(bulkGoalsUpdate: BulkGoalsUpdate[]): Promise<void>;
}

export interface IMonthlyBalanceRepo extends IRepository<IMonthlyBalanceDocument, IMonthlyBalance> {
  findMonthlyBalance(transaction: ITransaction, date: Date): Promise<IMonthlyBalance | null>;
}

export interface IUserRepo extends IRepository<IUserDocument, IUser> {
  findByEmail(email: string): Promise<IUser | null>;
}

export type IAccountRepo = IRepository<IAccountDocument, IAccount>;

export type ErrorHandler = (error: Error) => void;

export type RouteOverrides = {
  listContent?: (req: RequestWithUser, res: Response) => Promise<Response>;
  createContent?: (req: RequestWithUser, res: Response) => Promise<Response>;
  getContent?: (req: RequestWithUser, res: Response) => Promise<Response>;
  updateContent?: (req: RequestWithUser, res: Response) => Promise<Response>;
  deleteContent?: (req: RequestWithUser, res: Response) => Promise<Response>;
};

export interface IAccountantManager {
  createTransaction: (content: ITransaction) => Promise<ITransaction>;
  deleteTransaction: (id: string, userId: string, isAdmin: boolean) => Promise<ITransaction | null>;
  updateTransaction: (
    id: string,
    payload: Partial<ITransaction>,
    userId: string,
    isAdmin: boolean,
  ) => Promise<ITransaction | null>;
  getTransaction: (id: string, userId: string, isAdmin: boolean) => Promise<ITransaction | null>;
  listTransactions: (userId: string) => Promise<ITransaction[]>;
  getTransactionTypes: () => { transactionTypes: string[]; investmentTypes: string[] };
}

export interface ICommonController<T extends Content> {
  /**
     * Creates a new content.
     *
     * @throws {Error} - If no user is parsed in the request.
     * @throws {Error} - If the payload is void.
     *
     * @param req - The request object.
     * @param res - The response object.
     * @returns The created content.
     */
  createContent: (req: RequestWithUser, res: Response) => Promise<Response<T>>;
  /**
   * Updates a content.
   *
   * @throws {Error} - If no user is parsed in the request.
   * @throws {Error} - If the payload is void.
   * @throws {Error} - If the content is not found.
   * @throws {Error} - If the user is not authorized to update the content.
   *
   * @param req - The request object.
   * @param res - The response object.
   * @returns The updated content.
   */
  updateContent: (req: RequestWithUser, res: Response) => Promise<Response<T>>;
  /**
   * Deletes a content by id.
   *
   * @throws {Error} - If no user is parsed in the request.
   * @throws {Error} - If the content is not found.
   * @throws {Error} - If the user is not authorized to delete the content.
   * @throws {Error} - If the content id is not found in the request parameters.
   *
   * @param req - The request object.
   * @param res - The response object.
   * @returns The deleted content.
   */
  deleteContent: (req: RequestWithUser, res: Response) => Promise<Response<T>>;
  /**
   * Lists all content for a user.
   *
   * @throws {Error} - If no user is parsed in the request.
   *
   * @param req - The request object.
   * @param res - The response object.
   * @returns The list of content.
   */
  listContent: (req: RequestWithUser, res: Response) => Promise<Response<T>>;
  /**
   * Gets a content by id.
   *
   * @throws {Error} - If no user is parsed in the request.
   * @throws {Error} - If the content is not found.
   * @throws {Error} - If the content id is not found in the request parameters.
   *
   * @param req - The request object.
   * @param res - The response object.
   * @returns The content.
   */
  getContent: (req: RequestWithUser, res: Response) => Promise<Response<T>>;
}

export interface ICommonActions<K extends Content> {
  /**
   * Creates a new content.
   *
   * @throws {Error} - If the payload is void.
   *
   * @param content - The content to create.
   * @returns The created content.
   */
  createContent: (content: K) => Promise<K>;
  /**
   * Updates a content.
   *
   * @throws {Error} - If the payload is void.
   * @throws {Error} - If the content is not found.
   * @throws {Error} - If the user is not authorized to update the content.
   *
   * @param id - The id of the content to update.
   * @param payload - The payload to update the content with.
   * @param userId - The id of the user updating the content.
   * @param isAdmin - Whether the user is an admin.
   * @returns The updated content.
   */
  updateContent: (
    id: string,
    payload: Partial<K>,
    userId: string,
    isAdmin: boolean,
  ) => Promise<K | null>;
  /**
   * Deletes a content by id.
   *
   * @throws {Error} - If the content is not found.
   * @throws {Error} - If the user is not authorized to delete the content.
   *
   * @param id - The id of the content to delete.
   * @param userId - The id of the user deleting the content.
   * @param isAdmin - Whether the user is an admin.
   * @returns The deleted content.
   */
  deleteContent: (id: string, userId: string, isAdmin: boolean) => Promise<K | null>;
  /**
   * Lists all content for a user.
   *
   * @throws {Error} - If the user is not authorized to list the content.
   *
   * @param userId - The id of the user listing the content.
   * @returns The list of content.
   */
  listContent: (userId: string) => Promise<K[]>;
  /**
   * Gets a content by id.
   *
   * @throws {Error} - If the content is not found.
   * @throws {Error} - If the user is not authorized to get the content.
   *
   * @param id - The id of the content to get.
   * @param userId - The id of the user getting the content.
   * @param isAdmin - Whether the user is an admin.
   * @returns The content.
   */
  getContent: (id: string, userId: string, isAdmin: boolean) => Promise<K | null>;
}

export type ContentManagerActions = {
  budgetActions: ICommonActions<IBudget>;
  categoryActions: ICommonActions<ICategory>;
  goalActions: ICommonActions<IGoal>;
  accountActions: ICommonActions<IAccount>;
};

/* eslint-enable no-unused-vars */
